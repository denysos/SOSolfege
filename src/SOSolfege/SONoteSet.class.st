"
Store a collection of notes
can be used to store notes as parameters or for any other purpose, ...
used to store a chord, but not limited to chords

A Dictionary is used to store the note collection.
- notes are represented by their rank in the collection of all possible notes on the score
  (see class side) 
- to prevent duplicates
- to keep it ordered

Chords are generated by the generator, and then go thru DisplayCollector and DisplayRenderer





Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:

For the Class part:  State a one line summary. For example, ""I represent a paragraph of text"".

For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.

For the Collaborators Part: State my main collaborators and one line about how I interact with them. 

Public API and Key Messages

- message one   
- message two 
- (for bonus points) how to create instances.

   One simple example is simply gorgeous.
 
Internal Representation and Key Implementation Points.

    Instance Variables
	noteChoice:		<Object>


    Implementation Points
"
Class {
	#name : #SONoteSet,
	#superclass : #Object,
	#instVars : [
		'noteChoice'
	],
	#classVars : [
		'FullNotesCollection'
	],
	#category : #'SOSolfege-core'
}

{ #category : #exemple }
SONoteSet class >> newFullNoteSet [
	| aNoteSet maxRank |
	aNoteSet := self new.
	maxRank := SONoteData maxRank.
	1 to: maxRank do: [ :i | aNoteSet addANoteWithRank: i ].
	^ aNoteSet
]

{ #category : #exemple }
SONoteSet class >> newGKeyNoteSet [
	| aNoteSet |
	aNoteSet := self new.
	15 to: 29 do: [ :i | aNoteSet addANoteWithRank: i ].
	^ aNoteSet
]

{ #category : #adding }
SONoteSet >> addANote: aNoteData [
	noteChoice add: aNoteData.
	self removeDuplicates
]

{ #category : #adding }
SONoteSet >> addANoteWithRank: aRank [
	noteChoice add: (SONoteData fromRank: aRank).
	self removeDuplicates
]

{ #category : #'as yet unclassified' }
SONoteSet >> applyRule: aBlock [
	noteChoice in: aBlock
]

{ #category : #initialization }
SONoteSet >> initialize [
	super initialize.
	noteChoice := SortedCollection
		sortBlock: [ :noteData1 :noteData2 | noteData1 < noteData2 ]
]

{ #category : #testing }
SONoteSet >> isEmpty [
	^ self size = 0
]

{ #category : #enumerating }
SONoteSet >> notesDo: aBlockClosure [
	noteChoice do: aBlockClosure
]

{ #category : #printing }
SONoteSet >> printOn: aStream [
	noteChoice
		do: [ :each | 
			aStream
				nextPutAll: each name asString;
				space;
				space ]
]

{ #category : #private }
SONoteSet >> removeDuplicates [
	noteChoice removeDuplicates
]

{ #category : #initialization }
SONoteSet >> setOriginTo: aSelector [
	"perform: aSelector"

	| aNewNoteSet |
	aNewNoteSet := SONoteSet new.
	self
		notesDo: [ :eachNote | aNewNoteSet addANote: (eachNote perform: aSelector) ].
	^ aNewNoteSet
]

{ #category : #accessing }
SONoteSet >> size [
	^ noteChoice size
]

{ #category : #adding }
SONoteSet >> subsetAtRandomWith: anInteger [
	"pick some (anInteger) notes from the NoteSet and create a new NoteSet "

	| aNoteSet |
	aNoteSet := self class new.
	anInteger
		timesRepeat: [ aNoteSet addANote: noteChoice atRandom copy ].
	^ aNoteSet
]
